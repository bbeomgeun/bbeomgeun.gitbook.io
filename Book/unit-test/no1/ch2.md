# 2장 단위 테스트란 무엇인가
> 단위 테스트의 정의와 단위 테스트의 두 분파를 설명한다.
- 단위 테스트에 접근하는 방법이 두 가지 뚜렷한 견해로 나뉘었는데, 각각 고전파와 런던파로 알려져있다.
- 단위 테스트 정의로 시작한다.

## 2.1 '단위 테스트'의 정의
- 단위 테스트에는 많은 정의가 있지만, 가장 중요한 세 가지 속성이 있다.
  - 작은 코드 조각을 검증하고,
  - 빠르게 수행하고,
  - 격리된 방식으로 처리하는 자동화된 테스트다.
- 빠르게 수행하는 것에 대해선, 테스트 스위트의 실행 시간이 충분하다면 테스트가 충분히 빠르다는 의미다.
- 대중의 의견이 크게 다른 것은 세 번째 속성이다.
  - 격리 문제는 단위 테스트의 고전파와 런던파를 구분할 수 있게 해주는 근원적 차이다.

- 고전파는 단위 테스트에 대한 고전주의적 접근법
  - 가장 고전적인 책은 켄트 백의 테스트 주도 개발일 것이다.
- 런던파는 목 추종자로 표현된다.

### 2.1.1 격리 문제에 대한 런던파의 접근
- 런던파에서는 테스트 대상 시스템을 협력자에게서 격리하는 것을 일컫는다.
- 즉, 하나의 클래스가 다른 클래스 또는 여러 클래스에 의존하면 이 모든 의존성을 테스트 대역(test double)으로 대체해야 한다.
- 이런 식으로 동작을 외부 영향과 분리해서 테스트 대상 클레스에만 집중할 수 있다.
- **의존성이 포함된 테스트 대상 시스템을 검증하는 단위 테스트**는 의존성을 mocking함으로써 의존성과 별개로 수행할 수 있다.

<이점>
- 테스트가 실패 시 코드베이스의 어느 부분이 고장났는지 확실히 알 수 있다는 것이다.
  - 확실히 테스트 대상 시스템이 고장 난 것이다.
    - 의존성은 모두 테스트 대역 (mock)으로 대체됐기에 의심할 여지가 없다.
- 객체 그래프를 분할할 수 있다.
  - 모든 클래스가 각각 직접적인 의존성을 갖고 있으며 또 그 의존성이 또 다른 의존성을 갖고 있는 식으로, 그래프가 상당히 복잡해질 수 있다.
  - 따라서 의존성을 가진 코드베이스를 테스트하는 것은 테스트 대역 없이는 어렵다.
  - 테스트 대역을 사용하면 객체 그래프를 다시 만들지 않아도 된다.
    - 클래스의 직접적인 의존성을 대체할 수 있고, 더 나아가 의존성의 의존성을 다룰 필요도 없다.
- 한 번에 한 클래스만 테스트하라는 지침을 도입 시 전체 단위 테스트 스위트를 간단한 구조로 할 수 있다.
  - 클래스에 해당하는 단위 테스트 클래스를 생성하라!

> 테스트하고 싶은 시스템의 의존성은 모두 mocking함으로써 해당 시스템의 문제점을 정확히 파악할 수 있으며, 의존성을 mock으로 대체함으로써 의존성이 갖고 있는 또 다른 의존성의 고리를 끊어낼 수 있다.

- 고전적인 스타일로 작성된 테스트 예시

```
// 준비
var store = new Store();
store.AddInventory(Product.Shampoo, 10);
var customer = new Customer();

// 실행
bool success = customer.Purchase(store, Product.Shampoo, 5);

// 검증
Assert.True(success);
Assert.Equals(5, store.GetInventory(Product.Shampoo));
```

- 보다시피 준비 부분은 의존성과 테스트 대상 시스템을 모두 준비하는 부분이다.
  - 준비 단계에서는 테스트 대상 시스템 (SUT : System Under Test)과 하나의 협력자를 준비한다.
  - 이 경우 테스트 대상 클래스인 Customer가 SUT, Store이 협력자에 해당한다.
  - 협력자가 필요한 이유는?
    - 테스트 대상 메서드를 컴파일하려면 협력자 인스턴스가 필요로 하기 때문에

테스트 대상 메서드 (MUT, Method Under Test)는 테스트에서 호출한 SUT의 메서드다. MUT은 메서드를, SUT은 클래스 전체를 가리킨다.

위 코드는 단위 테스트의 고전 스타일 예로, 테스트는 협력자를 대체하지 않고 운영용 인스턴스를 사용한다.
- 고전 방식의 자연스러운 결과로, Customer와 Store 둘 다 효과적으로 검증한다.
  - 그러나 Customer가 정상 동작하더라도, 협력자인 Store 내부에 버그가 있으면 단위 테스트에 실패할 수 있다.
  - 즉, 테스트에서 두 클래스는 서로 격리돼 있지 않다.
위 코드를 런던 스타일로 바꿔보자.
- 구체적으로 목으로 교체해본다.

목은 테스트 대상 시스템과 협력자 간의 상호 작용을 검사할 수 있는 특별한 테스트 대역이다. 목은 테스트 대역의 부분집합이다.
- 테스트 대역은 실행과 관련 없이 모든 종류의 가짜 의존성을 설명하는 포괄적인 용어다.
- 목은 그러한 의존성의 한 종류일 뿐이다.

```
// Customer가 협력자인 Store에서 격리된 테스트 예제

// 준비
var storeMock = new Mock<IStore>();
storeMock
    .SetUp(x => x.HasEnoughInventory(Product.Shampoo, 5))
    .Returns(true);
var customer = new Customer();

// 실행
bool success = customer.Purchase(
    storeMock.Object, Product.Shampoo, 5);

// 검증
Assert.True(success);
storeMock.Verify(
    x => x.RemoveInventory(Product.Shampoo, 5);
    Times.Once);
```

- 런던 스타일 테스트는 실제 인스턴스를 생성하지 않고 Mock을 이용해서 대체한다.
- 또한 메서드 호출에 어떻게 응답하는지 목에 직접 정의한다.
  - Store의 실제 상태와 관계없이 테스트가 요구하는 방식으로 요청에 응답한다.
- 검증 단계에서도 중요한 차이점이 존재한다.
  - 이전에는 상점 상태를 검증했지만, 지금은 Customer와 Store 간의 상호 작용을 검사한다.
  - 즉, 고객이 상점에서 호출을 올바르게 했는지 확인한다.

### 2.1.2 격리 문제에 대한 고전파의 접근
- 런던 스타일은 테스트 대역(목)으로 테슽 대상 코드 조각을 분리해서 격리 요구사항에 다가간다.
  - 이 관점은 무엇이 작은 코드 조각에 해당하는지에 대한 견해에도 영향을 미친다.
    - 각각의 모든 클래스를 격리해야 한다면 테스트 대상 코드 조각은 당연히 단일 클래스이거나 해당 클래스 내의 메서드여야 한다.
    - 일반적으로 한 번에 한 클래스를 테스트하는 지침을 따르려고 노력해야 한다.
- 격리 특성을 해석하는 고전적인 방법에서는, 코드를 꼭 격리하는 방식으로 테스트해야 하는 것은 아니다.
  - 대신 단위 테스트는 서로 격리해서 실행해야 한다.
  - 이렇게 하면 테스트를 어떤 순서든 가장 적합한 방식으로 실행할 수 있으며 서로의 결과에 영향을 미치지 않는다.
- 공유 의존성을 사용 시 테스트 간 간섭이 일어나서 실패할 수 있다.
  - 데이터베이스의 데이터라던지, 파일 시스템 등 프로세스 외부 의존성

> #### 공유 의존성, 비공개 의존성, 프로세스 외부 의존성
> - 공유 의존성은 테스트 간에 공유되고 서로의 결과에 영향을 미칠 수 있는 수단을 제공하는 의존성이다.
>  - 공유 의존성의 전형적인 예는 정적 가변 필드다. 
> - 비공개 의존성은 공유하지 않는 의존성이다.
> - 프로세스 외부 의존성은 어플리케이션 실행 프로세스 외부에서 실행되는 의존성이며, 대부분 공유 의존성에 해당하지만 모두 그런 것은 아니다.
>   - 데이터베이스는 프로세스 외부이면서 공유 의존성이다.
>     - 하지만 각 테스트 실행 전 도커로 데이터베이스를 시작하면 테스트가 더 이상 동일한 인스턴스로 작동하지 않기 때문에 공유하지 않는 의존성이 된다.

- 공유 의존성은 테스트 대상 클래스 간이 아니라 단위 테스트 간에 공유한다.
  - 그런 의미에서 싱글턴 의존성은 공유되지 않는다.
  - 제품 코드에는 싱글턴 인스턴스가 하나만 있지만, 테스트는 이 패턴을 따르지 않고 재사용하지도 않는다.
  - 따라서 제품 코드에서는 싱글턴으로 모두가 공유한다고 생각할 수 있지만, 테스트에서는 비공개 의존성이다.

> 공유 의존성과 휘발성 의존성
> - 휘발성 의존성은 다음 속성 중 하나를 나타내는 의존성이다.
>   - 기본 설치된 환경 외에 런타임 환경의 설정 및 구성을 요구한다.
>   - 비결정적 동작을 포함한다. 난수 생성기 혹은 현재 날짜와 시간을 반환하는 클래스 등이 있다.

- 공유 의존성을 대체하는 또 다른 이유는 테스트 실행 속도를 높이는 데 있다.
  - 거의 항상 실행 프로세스 외부에 존재함으로 호출이 더 오래 걸린다.
  - 따라서 이러한 호출을 포함하는 공유 의존성을 가진 테스트는 단위 테스트 영역보다는 통합 테스트의 영역으로 넘어간다.

## 2.2 단위 테스트의 런던파와 고전파
- 보다시피 런던파와 고전파로 나눠진 원인은 격리 특성에 있다.
  - 런던파는 테스트 대상 시스템에서 협력자를 격리하는 것으로 보는 반면 (SUT 제외 mocking)
  - 고전파는 단위 테스트끼리 격리하는 것으로 본다.

|구분|격리 주체|단위의 크기|테스트 대역 사용 대상|
|---|---|---|---|
|런던파 | 단위 | 단일 클래스 | 불변 의존성 외 모든 의존성|
|고전파 | 단위 테스트 | 단일 클래스 또는 클래스 세트 | 공유 의존성|


### 2.2.1 고전파와 런던파가 의존성을 다루는 방법

## 2.3 고전파와 런던파의 비교

### 2.3.1 한 번에 한 클래스만 테스트하기

### 2.3.2 상호 연결된 클래스의 큰 그래프를 단위 테스트하기

### 2.3.3 버그 위치 정확히 찾아내기

### 2.3.4 고전파와 런던파 사이의 다른 차이점

## 2.4 두 분파의 통합 테스트

### 2.4.1 통합 테스트의 일부인 엔드 투 엔드 테스트

## 요약