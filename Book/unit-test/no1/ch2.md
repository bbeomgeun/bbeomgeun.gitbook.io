# 2장 단위 테스트란 무엇인가
> 단위 테스트의 정의와 단위 테스트의 두 분파를 설명한다.
- 단위 테스트에 접근하는 방법이 두 가지 뚜렷한 견해로 나뉘었는데, 각각 고전파와 런던파로 알려져있다.
- 단위 테스트 정의로 시작한다.

## 2.1 '단위 테스트'의 정의
- 단위 테스트에는 많은 정의가 있지만, 가장 중요한 세 가지 속성이 있다.
  - 작은 코드 조각을 검증하고,
  - 빠르게 수행하고,
  - 격리된 방식으로 처리하는 자동화된 테스트다.
- 빠르게 수행하는 것에 대해선, 테스트 스위트의 실행 시간이 충분하다면 테스트가 충분히 빠르다는 의미다.
- 대중의 의견이 크게 다른 것은 세 번째 속성이다.
  - 격리 문제는 단위 테스트의 고전파와 런던파를 구분할 수 있게 해주는 근원적 차이다.

- 고전파는 단위 테스트에 대한 고전주의적 접근법
  - 가장 고전적인 책은 켄트 백의 테스트 주도 개발일 것이다.
- 런던파는 목 추종자로 표현된다.

### 2.1.1 격리 문제에 대한 런던파의 접근
- 런던파에서는 테스트 대상 시스템을 협력자에게서 격리하는 것을 일컫는다.
- 즉, 하나의 클래스가 다른 클래스 또는 여러 클래스에 의존하면 이 모든 의존성을 테스트 대역(test double)으로 대체해야 한다.
- 이런 식으로 동작을 외부 영향과 분리해서 테스트 대상 클레스에만 집중할 수 있다.
- **의존성이 포함된 테스트 대상 시스템을 검증하는 단위 테스트**는 의존성을 mocking함으로써 의존성과 별개로 수행할 수 있다.

<이점>
- 테스트가 실패 시 코드베이스의 어느 부분이 고장났는지 확실히 알 수 있다는 것이다.
  - 확실히 테스트 대상 시스템이 고장 난 것이다.
    - 의존성은 모두 테스트 대역 (mock)으로 대체됐기에 의심할 여지가 없다.
- 객체 그래프를 분할할 수 있다.
  - 모든 클래스가 각각 직접적인 의존성을 갖고 있으며 또 그 의존성이 또 다른 의존성을 갖고 있는 식으로, 그래프가 상당히 복잡해질 수 있다.
  - 따라서 의존성을 가진 코드베이스를 테스트하는 것은 테스트 대역 없이는 어렵다.
  - 테스트 대역을 사용하면 객체 그래프를 다시 만들지 않아도 된다.
    - 클래스의 직접적인 의존성을 대체할 수 있고, 더 나아가 의존성의 의존성을 다룰 필요도 없다.
- 한 번에 한 클래스만 테스트하라는 지침을 도입 시 전체 단위 테스트 스위트를 간단한 구조로 할 수 있다.
  - 클래스에 해당하는 단위 테스트 클래스를 생성하라!

> 테스트하고 싶은 시스템의 의존성은 모두 mocking함으로써 해당 시스템의 문제점을 정확히 파악할 수 있으며, 의존성을 mock으로 대체함으로써 의존성이 갖고 있는 또 다른 의존성의 고리를 끊어낼 수 있다.

- 고전적인 스타일로 작성된 테스트 예시

```
// 준비
var store = new Store();
store.AddInventory(Product.Shampoo, 10);
var customer = new Customer();

// 실행
bool success = customer.Purchase(store, Product.Shampoo, 5);

// 검증
Assert.True(success);
Assert.Equals(5, store.GetInventory(Product.Shampoo));
```

- 보다시피 준비 부분은 의존성과 테스트 대상 시스템을 모두 준비하는 부분이다.
  - 준비 단계에서는 테스트 대상 시스템 (SUT : System Under Test)과 하나의 협력자를 준비한다.
  - 이 경우 테스트 대상 클래스인 Customer가 SUT, Store이 협력자에 해당한다.
  - 협력자가 필요한 이유는?
    - 테스트 대상 메서드를 컴파일하려면 협력자 인스턴스가 필요로 하기 때문에

테스트 대상 메서드 (MUT, Method Under Test)는 테스트에서 호출한 SUT의 메서드다. MUT은 메서드를, SUT은 클래스 전체를 가리킨다.

위 코드는 단위 테스트의 고전 스타일 예로, 테스트는 협력자를 대체하지 않고 운영용 인스턴스를 사용한다.
- 고전 방식의 자연스러운 결과로, Customer와 Store 둘 다 효과적으로 검증한다.
  - 그러나 Customer가 정상 동작하더라도, 협력자인 Store 내부에 버그가 있으면 단위 테스트에 실패할 수 있다.
  - 즉, 테스트에서 두 클래스는 서로 격리돼 있지 않다.
위 코드를 런던 스타일로 바꿔보자.
- 구체적으로 목으로 교체해본다.

목은 테스트 대상 시스템과 협력자 간의 상호 작용을 검사할 수 있는 특별한 테스트 대역이다. 목은 테스트 대역의 부분집합이다.
- 테스트 대역은 실행과 관련 없이 모든 종류의 가짜 의존성을 설명하는 포괄적인 용어다.
- 목은 그러한 의존성의 한 종류일 뿐이다.

```
// Customer가 협력자인 Store에서 격리된 테스트 예제

// 준비
var storeMock = new Mock<IStore>();
storeMock
    .SetUp(x => x.HasEnoughInventory(Product.Shampoo, 5))
    .Returns(true);
var customer = new Customer();

// 실행
bool success = customer.Purchase(
    storeMock.Object, Product.Shampoo, 5);

// 검증
Assert.True(success);
storeMock.Verify(
    x => x.RemoveInventory(Product.Shampoo, 5);
    Times.Once);
```

- 런던 스타일 테스트는 실제 인스턴스를 생성하지 않고 Mock을 이용해서 대체한다.
- 또한 메서드 호출에 어떻게 응답하는지 목에 직접 정의한다.
  - Store의 실제 상태와 관계없이 테스트가 요구하는 방식으로 요청에 응답한다.
- 검증 단계에서도 중요한 차이점이 존재한다.
  - 이전에는 상점 상태를 검증했지만, 지금은 Customer와 Store 간의 상호 작용을 검사한다.
  - 즉, 고객이 상점에서 호출을 올바르게 했는지 확인한다.

### 2.1.2 격리 문제에 대한 고전파의 접근
- 런던 스타일은 테스트 대역(목)으로 테슽 대상 코드 조각을 분리해서 격리 요구사항에 다가간다.
  - 이 관점은 무엇이 작은 코드 조각에 해당하는지에 대한 견해에도 영향을 미친다.
    - 각각의 모든 클래스를 격리해야 한다면 테스트 대상 코드 조각은 당연히 단일 클래스이거나 해당 클래스 내의 메서드여야 한다.
    - 일반적으로 한 번에 한 클래스를 테스트하는 지침을 따르려고 노력해야 한다.
- 격리 특성을 해석하는 고전적인 방법에서는, 코드를 꼭 격리하는 방식으로 테스트해야 하는 것은 아니다.
  - 대신 단위 테스트는 서로 격리해서 실행해야 한다.
  - 이렇게 하면 테스트를 어떤 순서든 가장 적합한 방식으로 실행할 수 있으며 서로의 결과에 영향을 미치지 않는다.
- 공유 의존성을 사용 시 테스트 간 간섭이 일어나서 실패할 수 있다.
  - 데이터베이스의 데이터라던지, 파일 시스템 등 프로세스 외부 의존성

> #### 공유 의존성, 비공개 의존성, 프로세스 외부 의존성
> - 공유 의존성은 테스트 간에 공유되고 서로의 결과에 영향을 미칠 수 있는 수단을 제공하는 의존성이다.
>  - 공유 의존성의 전형적인 예는 정적 가변 필드다. 
> - 비공개 의존성은 공유하지 않는 의존성이다.
> - 프로세스 외부 의존성은 어플리케이션 실행 프로세스 외부에서 실행되는 의존성이며, 대부분 공유 의존성에 해당하지만 모두 그런 것은 아니다.
>   - 데이터베이스는 프로세스 외부이면서 공유 의존성이다.
>     - 하지만 각 테스트 실행 전 도커로 데이터베이스를 시작하면 테스트가 더 이상 동일한 인스턴스로 작동하지 않기 때문에 공유하지 않는 의존성이 된다.

- 공유 의존성은 테스트 대상 클래스 간이 아니라 단위 테스트 간에 공유한다.
  - 그런 의미에서 싱글턴 의존성은 공유되지 않는다.
  - 제품 코드에는 싱글턴 인스턴스가 하나만 있지만, 테스트는 이 패턴을 따르지 않고 재사용하지도 않는다.
  - 따라서 제품 코드에서는 싱글턴으로 모두가 공유한다고 생각할 수 있지만, 테스트에서는 비공개 의존성이다.

> 공유 의존성과 휘발성 의존성
> - 휘발성 의존성은 다음 속성 중 하나를 나타내는 의존성이다.
>   - 기본 설치된 환경 외에 런타임 환경의 설정 및 구성을 요구한다.
>   - 비결정적 동작을 포함한다. 난수 생성기 혹은 현재 날짜와 시간을 반환하는 클래스 등이 있다.

- 공유 의존성을 대체하는 또 다른 이유는 테스트 실행 속도를 높이는 데 있다.
  - 거의 항상 실행 프로세스 외부에 존재함으로 호출이 더 오래 걸린다.
  - 따라서 이러한 호출을 포함하는 공유 의존성을 가진 테스트는 단위 테스트 영역보다는 통합 테스트의 영역으로 넘어간다.

## 2.2 단위 테스트의 런던파와 고전파
- 보다시피 런던파와 고전파로 나눠진 원인은 격리 특성에 있다.
  - 런던파는 테스트 대상 시스템에서 협력자를 격리하는 것으로 보는 반면 (SUT 제외 mocking)
  - 고전파는 단위 테스트끼리 격리하는 것으로 본다.

|구분|격리 주체|단위의 크기|테스트 대역 사용 대상|
|---|---|---|---|
|런던파 | 단위 | 단일 클래스 | 불변 의존성 외 모든 의존성|
|고전파 | 단위 테스트 | 단일 클래스 또는 클래스 세트 | 공유 의존성|


### 2.2.1 고전파와 런던파가 의존성을 다루는 방법
- 불변 객체는 교체하지 않아도 된다.
- 이러한 불변 객체를 값 객체 (Value Object) 또는 값 (Value)이라고 한다. 주요 특징은 각각의 정체성이 없다는 것이다.
- 즉, 내용에 의해서만 식별된다.
  - 그 결과, 두 객체가 동일한 내용을 갖고 있다면 어떤 객체를 사용하든 상관없다.
  - 값 객체는 언어나 프레임워크에 구애받지 않는다.

> 협력자 대 의존성
> - 협력자는 공유하거나 변경 가능한 의존성이다.
>   - 데이터베이스는 공유 의존성이므로 데이터베이스 접근 권한을 제공하는 클래스는 협력자이다.
>   - 값은 협력자가 아니다.

공유 의존성과 프로세스 외부 의존성이라는 용어는 서로 바꿀 수 있다.
- 실제 프로젝트에서 프로세스 외부가 아닌 공유 의존성은 거의 없다. 
- 의존성이 프로세스 내부에 있으면 각 테스트에서 별도의 인스턴스를 쉽게 공급할 수 있으므로 테스트 간에 공유할 필요가 없다.

## 2.3 고전파와 런던파의 비교
- 고전파와 런던파 간의 주요 차이는 단위 테스트의 정의에서 격리 문제를 어떻게 다루는지에 있다.
  - 이는 테스트해야 할 단위의 처리와 의존성 취급에 대한 방법으로 넘어간다.
- 고전파의 단위 테스트는
  - 목을 사용하지 않기에 고품질의 테스트를 만들고 단위 테스트의 궁극적인 목표인 프로젝트의 지속 가능한 성장을 달성하는데 더 적합하다.
  - 취약성이 이유인데, 목을 사용한 테스트는 고전적인 테스트보다 불안정한 경향이 있기 때문이다.

하지만 지금은 런던파의 주요 장점을 살펴보면
1. 입자성이 좋다. 테스트가 세밀해서 한 번에 한 클래스만 확인한다.
2. 서로 연결된 클래스의 그래프가 커져도 테스트하기 쉽다.
   1. 모든 협력자는 테스트 대역으로 대체되기 때문에 테스트 작성시 걱정할 필요가 없다.
3. 테스트가 실패하면 어떤 기능이 실패했는지 확실히 알 수 있다.
   1. 클래스의 협력자가 없으면 테스트 대상 클래스 외에 다른 것을 의심할 여지가 없다.


### 2.3.1 한 번에 한 클래스만 테스트하기
- 좋은 입자성에 관한 요점은 단위 테스트에서 단위를 구성하는 것에 대한 논쟁과 관련이 있다.
  - 런던파는 클래스를 단위로 간주한다.

> 테스트는 코드의 단위를 검증해서는 안 된다. 오히려 동작의 단위, 즉 문제 영역에 의미가 있는 것. 이상적으로는 비즈니스 담당자가 유용하다고 인식할 수 있는 것을 검증해야 한다.
> 그 동작 단위를 구성하는데 클래스가 얼마나 필요한지는 상관 없다.
> 우리가 테스트하고 싶은 행위의 단위는 여러 클래스에 걸쳐 있거나, 한 클래스에만 있거나, 아주 작은 메서드가 될 수도 있다.

- 그래서 좋은 코드 입자성을 목표로 하는 것은 도움이 되지 않고 테스트가 단일 동작 단위를 검증하는 한 좋은 테스트다.
- 테스트는 해결하는 데 도움이 되는 문제에 대한 이야기를 들려줘야 하며, 이 이야기는 프로그래머가 아닌 일반 사람들에게 응집도가 높고 의미가 있어야 한다.

### 2.3.2 상호 연결된 클래스의 큰 그래프를 단위 테스트하기
- 실제 ㅎ벼력자를 대신해 목을 사용하면 클래스를 쉽게 테스트할 수 있다.
- 특히 테스트 대상 클래스에 의존성이 있고, 이 의존성에 다시 각각의 의존성이 있고, 이렇게 여러 계층에 걸쳐서 계속되는 식으로 의존성 그래프가 복잡하게 된다면 쉽게 테스트할 수 있다.
  - 고전파의 경우 전체 객체 그래프를 다시 생성해야 하는데, 작업량이 많을 수 있다.
- 그러나 애초에 상호 연결된 클래스의 크고 복잡한 그래프를 테스트할 방법을 찾기보다는, 먼저 이러한 클래스 그래프를 갖지 않는 데 집중해야 한다.
  - 대개 클래스 그래프가 커진 것은 코드 설계 문제의 결과다.
- 테스트에서 이 문제를 지적한 것은 좋은 일이다. 비교적 높은 정확도로 저품질을 예측한다.
  - 목을 사용하는 것은 이 문제를 감추기만 할 뿐, 원인을 해결하지 못한다.

### 2.3.3 버그 위치 정확히 찾아내기
- 런던 스타일의 경우 테스트 시스템에 버그가 생기면, SUT에 버그가 포함된 테스트만 실패한다.
- 고전적인 방식의 경우, 오작동하는 클래스를 참조하는 클라이언트를 대상으로 하는 테스트도 실패할 수 있다.
  - 하나의 버그가 전체 시스템에 걸쳐 실패할 수 있기에, 결국 문제의 원인을 찾기가 더 어려워진다.
- 하지만 큰 문제는 아니다. 소스 코드가 변경될 때마다 테스트를 실행하면 버그의 원인을 알아낼 수 있다.
- 게다가 테스트 스위트 전체에 걸쳐 계단식으로 실패하는 데 가치가 있다.
  - 고장 낸 코드 조각이 테스트 하나뿐만 아니라 많은 테스트의 결함으로 이어진다면 가치가 있다는 것을 보여준다.

### 2.3.4 고전파와 런던파 사이의 다른 차이점
- 남아 있는 두 가지 차이점은 다음과 같다.
  - 테스트 주도 개발을 통한 시스템 설계 방식
  - 과도한 명세 문제

- 이 중 가장 중요한 차이점은 과도한 명세 문제, 즉 테스트가 SUT의 구현 세부사항에 결합되는 것이다.
  - 런던 스타일은 고전 스타일보다 테스트가 구현에 더 자주 결합되는 편이다.
  - 이로 인해 런던 스타일과 목을 전반적으로 아무 데나 쓰는 것에 대해 주로 이의가 제기된다.

## 2.4 두 분파의 통합 테스트
- 통합 테스트의 정의에도 차이가 있다.
- 런던파는 실제 협력자 객체를 사용하는 모든 테스트를 통합 테스트로 간주한다.
  - 고전파 스타일의 대부분의 테스트는 런던파에게 통합 테스트로 느껴질 것이다.

- 단위 테스트는
  - 단일 동작 단위를 검증하고
  - 빠르게 수행하고
  - 다른 테스트와 별도로 처리한다.

- 통합 테스트는
  - 공유 의존성에 접근하는 테스트는 다른 테스트와 분리해 실행할 수 없다.
    - 특정 테스트에서 데이터베이스 상태 변경이 생기면 병렬로 실행할 때 동일한 데이터베이스에 의존하는 다른 모든 테스트의 결과가 변경될 것이다.
  - 마찬가지로 프로세스 외부 의존성에 접근하면 테스트가 느려진다.
  - 마지막으로, 둘 이상의 동작 단위를 검증할 때의 테스트는 통합 테스트이다.

- 통합 테스트는 시스템 전체를 검증해 소프트웨어 품질을 기여하는 데 중요한 역할을 한다.

### 2.4.1 통합 테스트의 일부인 엔드 투 엔드 테스트
- 간단히 말해 통합 테스트는 공유 의존성, 프로세스 외부 의존성뿐 아니라 조직 내 다른 팀이 개발한 코드 등과 통합해 작동하는지도 검증하는 테스트다.
- 엔드 투 엔드 테스트라는 개념도 따로 있는데, 통합 테스트의 일부다.
  - E2E 테스트도 코드가 프로세스 외부 종속성과 함께 어떻게 동작하는지 검증한다.
  - 차이점은 E2E 테스트가 일반적으로 의존성을 더 많이 포함한다는 것이다.
  - 통합 테스트는 프로세스 외부 의존성을 한두개만 갖고 동작한다고 하면, E2E 테스트는 전부 또는 대다수를 갖고 작동한다.
    - 모든 외부 어플리케이션을 포함해 시스템을 최종 사용자의 관점에서 검증하는 것을 의마한다.
    - UI 테스트, GUI 테스트, 기능 테스트와 같은 용어와 모두 동의어다.
- 따라서 유지 보수 측면에서 가장 비용이 많이 들기 때문에 모든 단위 테스트와 통합 테스트를 통과한 후 후반에 실행하는 것이 좋다.

## 요약
- 단위 테스트의 정의를 다듬었다.
  - 단일 동작 단위를 검증하고, 빠르게 수행하고, 다른 테스트와 별도로 처리한다.
- 격리 문제의 논의로 고전파와 런던파 분파로 나뉘었다.
  - 단위가 무엇을 의미하는지와 SUT의 의존성 처리 방식에 영향을 끼쳤다.
    - 런던파는 불변 의존성을 제외한 모든 의존성을 대체해야 하고
    - 고전파는 동작 단위로 공유 의존성만 대체해야 한다.
- 런던파는 입자성의 이점, 클래스 의존 그래프에 대한 테스트 용이성, 버그를 쉽게 찾을 수 있는 편의성을 제공한다.
- 런던파가 매력적으로 보일 수 있지만, 몇 가지 문제점이 있다.
  - 단위 테스트 대상 클래스에 대한 초점이 잘못됐다.
    - 코드 단위가 아닌 동작 단위를 검증해야 한다.
  - Mock을 사용한다해도 해결이 아닌 숨기는 것이다.
  - 테스트 실패 후 어떤 기능에 버그가 있는지 판단에 도움이 되지만, 종종 버그의 원인을 알고 있기에 큰 문제가 아니다.
    - 마지막에 수정한 것이 버그의 원인일 것이다.
- 런던파 테스트의 가장 큰 문제는 과잉 명세, SUT 세부 구현에 결합된 테스트 문제이다.
- 통합 테스트는 단위 테스트의 기준 중 하나 이상을 충족하지 못하는 테스트이다.
- E2E 테스트는 통합 테스트의 일부이다.
- 고전적인 스타일을 다룬 명저는 켄트 백의 TDD를 추천한다.