# 4장 좋은 단위 테스트의 4대 요소
> 좋은 단위 테스트를 구성하고 이 책 전체에서 사용되는 공통적인 기준틀이 되는 4대 요소를 정의한다.

- 가치 있는 테스트를 식별하는 것과 가치 있는 테스트를 작성하는 것은 별개의 기술이다.
- 가치 있는 테스트를 작성하려면 가치 있는 테스트를 식별할 수 있어야 한다.
- 이번 장에서는 가치 있는 테스트를 식별하는 방법을 알아본다.

## 4.1 좋은 단위 테스트의 4대 요소 자세히 살펴보기
1. 회귀 방지
2. 리팩터링 내성
3. 빠른 피드백
4. 유지 보수성

### 4.1.1 첫 번째 요소: 회귀 방지
- 회귀는 소프트웨어 버그다.
  - 코드를 수정한 후 기능이 의도한 대로 작동하지 않는 경우다.
  - 코드베이스가 커질수록 잠재적인 버그에 더 많이 노출된다.
  - 따라서 회귀에 대해 효과적인 보호를 개발하는 것이 중요하다.
    - 이러한 보호가 없다면 프로젝트가 오랫동안 성장할 수 없으며 점점 더 많은 버그가 쌓일 것이다.

- 회귀 방지 지표에 대한 평가는 다음 사항을 고려해야 한다.
1. 테스트 중에 실행되는 코드의 양
2. 코드 복잡도
3. 코드의 도메인 유의성

일반적으로 실행되는 코드가 많을수록 테스트에서 회귀가 나타날 가능성이 높다.
또한, 코드의 양뿐만 아니라 복잡도와 도메인 유의성도 중요하다.
- 복잡한 비즈니스 로직의 코드가 보일러플레이트 코드보다 훨씬 더 중요하다.
- 비즈니스 버그가 가장 큰 피해를 입히기 때문이다.
- 반면 단순한 코드를 테스트하는 것은 가치가 거의 없다.

> 팁
> - 회귀 방지 지표를 극대화하려면 테스트가 가능한 한 많은 코드를 실행하는 것을 목표로 해야 한다.
> - 버그를 막아주는 테스트 코드, 특히 핵심 비즈니스 로직을 테스트하는 단위 테스트가 좋은 단위 테스트이다.

### 4.1.2 두 번째 요소: 리팩터링 내성
- 좋은 단위 테스트의 두 번째 특징은 리팩터링 내성이다. 이는 테스트를 '빨간색'으로 바꾸지 않고 기본 어플리케이션 코드를 리팩터링할 수 있는지에 대한 척도다.

> 리팩터링은 식별할 수 있는 동작을 수정하지 않고 기존 코드를 변경하는 것을 의미한다.
> - 그 의도는 코드의 비기능적 특징을 개선하는 것으로 가독성을 높이고 복잡도를 낮추는 것이다.

- 상황 가정
  - 새로운 기능을 개발했으며 모든 것이 잘 작동한다.
  - 기능이 제 역할을 하고 있으며, 모든 테스트가 통과하고 있다.
  - 이제 코드를 정리하기로 결정했다.
    - 리팩터링으로 정확히 무엇이 고장 났는지 자세히 살펴봤지만, 아무것도 고장 나지 않았다.
    - 문제는 기반 코드를 수정 시 테스트가 빨간색으로 바뀌게끔 작성됐다는 것이다.
    - 그리고 실제로 기능이 작동하지 않는지는 상관없다.
      - 이러한 상황을 **거짓 양성**이라고 한다. 허위 경보인 셈이다.
      - 코드는 잘 동작하지만 테스트는 실패를 나타내는 결과다.

거짓 양성이 적을수록 리팩터링 내성 지표에서 테스트 점수가 잘 나올 것이다.

- 왜 거짓 양성을 신경써야 할까?
  - 단위 테스트의 목표는 프로젝트 성장을 지속 가능하게 하는 것이다.
  - 테스트가 지속 가능한 성장을 하게 하는 메커니즘은 **회귀 없이 주기적으로 리팩터링하고 새로운 기능을 추가**할 수 있는 것이다.
  - 장점
    1. 기존 기능이 고장 났을 때 테스트가 조기 경고를 제공한다. 운영 환경에 배포되기 전에 결함이 있는 코드를 고칠 수 있다.
    2. 코드 변경이 회귀로 이어지지 않을 것이라고 확신하게 된다. 확신이 없으면 리팩터링을 하는 데 주저하게 되고 코드베이스가 나빠질 가능성이 있다.
  - 거짓 양성은 이 두 가지 이점을 모두 방해한다.
    1. 테스트가 타당한 이유 없이 실패하면, 코드 문제에 대응하는 능력과 의지가 희석된다. 시간이 지나며 실패에 익숙해지고 신경 쓰지 않으며 무시하기 시작한다.
    2. 거짓 양성이 빈번해지면, 테스트 스위트에 대한 신뢰가 떨어지며 믿을 만한 안정망으로 인식하지 않는다. 즉, 허위 경보로 인식이 나빠진다.
- 즉, 계속 "늑대"라고 외치는 양치기 소년 같은 테스트에 질려서 점점 무시하기 시작한다.
- 무시하기 시작하며 버그가 운영 환경에 릴리즈 되는 순간이 오게 된다.

### 4.1.3 무엇이 거짓 양성의 원인인가?
- 테스트에서 발생하는 거짓 양성의 수는 테스트 구성 방식과 직접적인 관련이 있다.
- 테스트와 테스트 대상 시스템(SUT)의 구현 세부 사항이 많이 결합될수록 허위 경보가 더 많이 생긴다.
  - 따라서 거짓 양성을 줄이는 방법은 해당 구현 세부 사항에서 테스트를 분리하는 것 뿐이다.
  - 테스트를 통해 SUT가 제공하는 최종 결과를 검증하는지 확인해야 한다.
  - 즉, 최종 사용자에게 의미 있는 결과만 확인해야 한다. 다른 것은 무시해야 한다.
- 테스트를 구성하기에 가장 좋은 방법은 문제 영역에 대해 이야기하는 것이다.
  - 이 테스트가 실패하면 실제로 어플리케이션 동작과 이야기가 서로 분리되는 것을 의미한다.
  - 그 외 실패는 소음일뿐이다.

테스트를 구현에 신경 쓴다고 하면
- 최종 결과가 바뀌지 않더라도, 테스트를 수행 시 빨간색으로 변할 것이다.
- 이는 테스트가 SUT가 생성한 결과가 아니라 SUT의 구현 세부사항과 결합했기 때문이다.
  - 이런 테스트는 리팩터링 내성이 없다.
  - 식별할 수 있는 동작을 고려하지 않고 특정한 구현에만 고집한다.
  - 따라서 내부 구현이 변경될 때마다 테스트가 실패할 것이다.

### 4.1.4 구현 세부 사항 대신 최종 결과를 목표로 하기
- 테스트를 깨지지 않게 하고 리팩터링 내성을 높이는 방법은 SUT의 구현 세부 사항과 테스트 간의 결합도를 낮추는 것뿐이다.
- 코드의 내부 작업과 테스트 사이를 가능한 한 멀리 떨어뜨리고 최종 결과를 목표로 하는 것이다.
- 최종 사용자에게 의미 있는 유일한 결과, 방식을 검증해 비즈니스 요구 사항에 들어맞게끔 작성하자.
- 메서드에 새 매개변수를 도입하면 컴파일 오류가 발생할 수 있다.
  - 기술적으로 이러한 오류도 거짓 양성으로 간주하지만, 컴파일러를 따라 새 매개변수를 추가하면 된다.
  - 좋지 않은 거짓 양성은 컴파일 오류를 내지 않는 것이다.
  - 처리하기 까다롭다.
  - 조사하는데 많은 시간을 들여야 하기 때문이다.

> 테스트의 세부 구현까지 모두 테스트하려는 시도가 오히려 리팩토링 내성이 없는 테스트 코드를 작성하는 행위였다.

## 4.2 첫 번째 특성과 두 번째 특성 간의 본질적인 관계
- 단위 테스트의 두 요소 사이에는 본질적인 관계가 있다.
  - 둘 다 정반대의 관점에서도 테스트 스위트의 정확도에 기여한다.
  - 프로젝트가 시작 후에는 회귀 방지를 훌륭히 갖추는 것이 중요한 데 반해, 리팩터링 내성은 바로 필요하지 않다.

### 4.2.1 테스트 정확도 극대화

|오류 유형 표|작동|고장|
|---|---|---|
|테스트 통과|올바른 추론 (참 음성) | 2종 오류 (거짓 음성)
|테스트 실패|1종 오류 (거짓 양성) | 올바른 추론 (참 양성)

- 테스트가 통과하고 기본 기능이 의도한 대로 잘 작동하는 상황은 올바른 추론이다. 테스트는 시스템의 상태를 올바르게 유추했다. (버그 없음) - 참 음성
- 마찬가지로 기능이 고장 나서 테스트가 실패해도 올바른 추론이다. 기능이 제대로 작동하지 않으면 테스트가 실패할 것으로 예상하기 때문이다. - 참 양성
- 테스트에서 오류가 발생하지 않으면 문제가 된다 - 거짓 음성
  - 오류가 있음에도 (거짓) 없다고 하는 (음성) 상황이다. (버그 발생)
    - 위 상황을 막기 위해 회귀 방지가 도움이 된다.
- 기능은 올바르지만 테스트가 여전히 실패로 표시된다. - 거짓 양성
  - 오류는 없지만(거짓) 오류가 있다고 (양성) 하는 상황이다.
    - 위 상황을 피하기 위해 리팩터링 내성이 도움이 된다.

> 양성과 음성에 대한 이해
> - 독감 검사를 생각하면 된다.
>   - **독감 검사는 검사를 받는 사람이 독감에 걸렸을 때 긍정(positive)이다.**
>   - 마찬가지로 **독감이 없으면 독감 검사는 부정(negative)**이 된다.

즉, 거짓 양성과 거짓 음성의 확률이 테스트의 수준을 나타낸다.
확률이 낮을 수록 테스트가 더 정확하다.

- 회귀 방지와 리팩터링 내성은 테스트 스위트의 정확도를 극대화하는 것을 목표로 한다.
  - 테스트가 버그 있음을 얼마나 잘 나타내는가?
  - 테스트가 버그 없음을 얼마나 잘 나타내는가?

테스트 정확도 = 신호 (발견된 버그 수) / 소음 (허위 경보 발생 수)
- 분자를 증가시키거나 (버그를 잘 찾아내도록) 분모를 줄이거나 (허위 경보를 발생시키지 않도록).

### 4.2.2 거짓 양성과 거짓 음성의 중요성 : 역학 관계
- 처음에는 거짓 양성도 나쁘지 않다. 시작 시 잘못된 경고를 받는 것은 경고를 전혀 받지 않아 운영에 버그가 들어가는 위험을 감수하는 것보다는 낫기 때문이다.
  - 그러나 프로젝트가 성장함에 따라 거짓 양성은 테스트 스위트에 점점 더 큰 영향을 미치기 시작한다.
- 처음에는 왜 거짓 양성이 중요하지 않은가?
  - 리팩터링이 바로 중요하진 않으며, 시간이 지나면서 점차 중요해진다.
  - 초기에는 프로젝트 정리를 많이 할 필요가 없다.
  - 코드가 반짝반짝하고 아직 생생하기에 잘못된 경보가 발생해도 바로 고칠 수 있다.
- 하지만 시간이 지날수록 코드베이스는 나빠진다.
  - 점점 더 복잡해지고 체계적이지 않게 된다.
    - 따라서 이러한 경향을 줄이려면 정기적으로 리팩터링을 해야 한다.
    - 그러므로 리팩터링 내성도 점점 더 중요해진다.
      - 계속 늑대라고 울리면 리팩터링을 할 수 없고, 테스트에 대해 신뢰를 잃어버린다.
- 대부분 회귀 방지에만 중점을 두고 리팩터링 내성 - 거짓 양성을 신경 쓰는 개발자는 거의 없다.
  - 프로젝트가 후반까지 가지 않는 상황도 있지만, 거짓 음성과 거짓 양성에 대해 똑같이 주의를 기울어야 한다.

## 4.3 세 번째 요소와 네 번째 요소 : 빠른 피드백과 유지 보수성
- 빠른 피드백과 유지 보수성
  1. 빠른 피드백
     - 빠를 수록 테스트 스위트에서 더 많은 테스트를 수행할 수 있고 더 자주 실행할 수 있다.
       - 피드백 루프를 줄여서 빠른 피드백이 가능해진다.
       - 그렇지 않다면 오래 걸리는 테스트는 자주 실행하지 못해서 나중에 수정하기 위해 시간을 더 많이 낭비한다.
  2. 유지 보수성
      - 유지 보수성 지표는 유지비를 평가한다.
        - 테스트가 얼마나 이해하기 어려운가?
          - 코드 라인이 적을수록 읽기 쉽지만 인위적으로 줄이지 말자.
          - 테스트 코드를 **일급 시민**으로 취급하라.
        - 테스트가 얼마나 실행하기 어려운가?
          - 외부 종속성으로 인해 DB나 네트워크 문제 등을 해결해야 한다면?

> 확실히 테스트가 느리다면 개발 시에 테스트를 돌리는 것에 부담감이 생긴다. 테스트가 많지 않다면 뭐가 문제일까 라고 생각할 수 있는데, 느린 테스트들이 점점 쌓이면 한 번 돌리는데 몇 분이 걸릴 수 있고 자주 안돌리게 되고 소외된다.

## 4.4 이상적인 테스트를 찾아서
- 좋은 단위 테스트의 4대 특성을 다시 보면 다음과 같다.
1. 회귀 방지
2. 리팩터링 내성
3. 빠른 피드백
4. 유지 보수성

이 네 가지 특성을 곱하면 테스트의 가치가 결정된다. 즉, 어떤 특성이라도 0이라면 전체 가 0이 된다.

테스트 코드를 포함한 모든 코드는 책임(liability)이다. 최소 필수값에 대해 상당히 높은 임계치를 설정하고 이 임계치를 충족하는 테스트만 테스트 스위트에 남겨라.
- 소수의 매우 가치 있는 테스트는 다수의 평범한 테스트보다 프로젝트가 계속 성장하는 데 훨씬 더 효과적이다.
몇 가지 예를 들어본다.

### 4.4.1 이상적인 테스트를 만들 수 있는가?
- 이상적인 테스트는 네 가지 특성을 모두 최대 점수를 받는 테스트다.
  - 하지만 불가능하다.
  - 회귀 방지, 리팩터링 내성, 빠른 피드백은 상호 배타적이기 때문이다.
- 더욱이 곱셈 원리 때문에 균형을 유지하는 것이 더욱 까다롭다.
  - 다른 특성에 집중하려고 하나의 특성을 그냥 버릴 수는 없다.
  - 두 특성을 최대로 하는 것을 목표로 해서 한 가지 특성을 희생해 결국 가치가 0에 가까워진 테스트를 몇 가지 예로 살펴보자.

### 4.4.2 극단적인 사례 1 : 엔드 투 엔드 테스트
- 첫 번째 예는 엔드 투 엔드 테스트다.
  - 최종 사용자의 관점에서 시스템을 살펴보는 테스트로, 모든 시스템 구성 요소를 거치게 된다.
  - E2E 테스트는 많은 코드를 테스트하므로 회귀 방지를 훌륭해 해낸다.
  - 또한, 거짓 양성에 면역이 돼 리팩터링 내성도 우수하다.
    - 리팩터링은 식별할 수 있는 동작을 변경하지 않으므로 영향을 미치지 않는다.
    - E2E 테스트는 최종 사용자의 관점에서 기능이 어떻게 동작하는지만 볼 수 있으며, 구현 세부 사항을 최대한 제거했다.
- 그러나 큰 단점이 있다.
  - 바로 느린 속도인데, E2E 테스트만 작성하는 개발 조직은 빠른 피드백을 받기 어려울 것이다. 그리고 많은 개발 팀의 큰 걸림돌이다.
    - 이는 E2E 테스트만으로 코드 베이스를 다루기가 불가능한 까닭이다.

> 회귀 방지, 리팩터링 내성 OK / 빠른 피드백 NO

### 4.4.3 극단적인 사례 2 : 간단한 테스트
- 너무나도 단순해서 고장이 없을 것 같은 작은 코드 조각을 다룬다.

``` java
public class User {
    public string Name {get; set;}
}

public void Test() {
    var sut = new User();

    sut.Name = "John Smith";

    Assert.equal("John Smith", sut.Name);
}
```

- 매우 빠르게 실행되고 빠른 피드백을 제공한다.
- 또한 거짓 양성이 생길 가능성이 상당히 낮기 때문에 리팩터링 내성도 우수하다.
- 그러나 기반 코드에 실수할 여지가 많기 때문에 간단한 테스트는 회귀를 나타내지 않을 것이다.

사실상 테스트가 항상 통과하고, 무의미해질 수 있다.

> 리팩터링 내성, 빠른 피드백 OK / 회귀 방지 NO

### 4.4.4 극단적인 사례 3 : 깨지기 쉬운 테스트
- 실행이 빠르고 회귀를 잡을 가능성이 높지만 거짓 양성이 많은 테스트를 작성하기 쉬운데, 이러한 테스트를 '깨지기 쉬운 테스트'라고 한다.
- 이는 리팩터링을 견디지 못하고, 고장 여부와 관계 없이 빨간색으로 바뀐다.
- 기능은 계속 작동하지만 SUT의 내부 구현 세부 사항에 결합되어 있을 경우 계속 빨간색으로 바뀐다.

이 테스트는 무엇보다 '어떻게'에 중점을 두고 있기 때문에 더 이상의 리팩터링은 막으면서 SUT의 구현 세부 사항에 스며들고 있다.

> 빠른 피드백, 회귀 방지 OK, 리팩터링 내성 NO

### 4.4.5 이상적인 테스트를 찾아서 : 결론
- 위 3가지 특성은 상호 배타적이라 모두 완벽한 테스트는 불가능하다.
  - 네 번째 특성인 유지 보수성은 E2E를 제외하고 위 3가지 특성과는 상관관계가 없다.
- 좋은 테스트를 만드는 특성 간에 균형을 이뤄내는 것은 쉽지 않다.
- 따라서 절충해야 한다. 부분적으로 그리고 전략적으로 희생해야 한다.

리팩터링 내성은 포기할 수 없다. E2E 테스트만 쓰거나 테스트가 상당히 빠르지 않은 한, 리팩터링 내성을 최대한 많이 갖는 것을 목표로 해야 한다.
- 따라서 테스트가 얼마나 버그를 잘 찾아내는지 (회귀 방지), 얼마나 빠른지 (빠른 피드백) 사이의 선택으로 절충이 귀결된다.
- 리팩터링 내성을 포기할 수 없는 이유는, 보통 있거나 없거나 둘 중 하나기 때문이다.
  - 중간 단계가 거의 없지만, 회귀 방지와 빠른 피드백의 지표는 조절이 가능하다.

> CAP 정리
> - 좋은 단위 테스트의 세 가지 특성 간의 상충 관계는 CAP 정리와 유사하다. 분산 데이터 저장소가 다음 세 가지 보증 모두를 동시에 제공할 수 없음을 나타낸다.
>   - 일관성 (consistency) : 모든 읽기가 가장 최근의 쓰기 또는 오류를 수신하는 것을 의미한다.
>   - 가용성 (availability) : 모든 요청이 응답을 수신하는 것을 의미한다.
>   - 분할 내성 (partition tolerance) : 네트워크 분할(노드 간 연결 끊김)에도 시스템이 계속 작동함을 의미한다.
> - 두 가지 비슷한 점이 있다.
>   1. 세 가지 중 두 가지를 선택하는 절충안을 선택해야 한다.
>   2. 대규모 분산 시스템의 분할 내성도 타협할 수 없다. 아마존 웹 사이트와 같은 대규모 어플리케이션은 단일 머신에서 동작할 수 없기에, 분할 내성을 희생할 수 없다. 아무리 큰 서버일지라도 서버 한 대에 저장하기에는 데이터가 너무 많다.
> - 그렇다면 결국 선택은 일관성과 가용성 간의 절충으로 귀결된다.
> - 각 상황에 맞게 우선순위를 조절한다.

## 4.5 대중적인 테스트 자동화 개념 살펴보기
- 앞의 좋은 단위 테스트의 네 가지 특성은 기초에 해당한다.
- 이 장에서는 테스트 피라미드와 화이트박스 테스트 대 블랙박스 테스트라는 두 가지 개념을 살펴보기로 한다.

### 4.5.1 테스트 피라미드 분해
- 테스트 피라미드는 테스트 스위트에서 테스트 유형 간의 일정한 비율을 일컫는 개념이다.

E2E << 통합 테스트 <<< 단위 테스트 (테스트 수)
E2E >> 통합 테스트 >>> 단위 테스트 (사용자 모방)

밑으로 갈수록 테스트가 얼마나 보편적인지, 많은지 나타낸다.
층의 높이는 테스트가 최종 사용자의 동작을 얼마나 유사하게 흉내 내는지 나타내는 척도다.

- 어느 계층도 리팩터링 내성을 포기하진 않는다.
- E2E 테스트는 회귀 방지에 유리하고, 단위 테스트는 빠른 피드백을 강조하며, 통합 테스트는 그 중간에 있다.

테스트 유형 간의 정확한 비율은 각 팀과 프로젝트마다 다를 것인데, 일반적으로 피라미드 형태를 유지해야 한다. 즉, E2E 테스트가 가장 적고, 단위 테스트가 가장 많으며, 통합 테스트는 중간 어딘가에 있어야 한다.

- E2E가 적어야 하는 이유는
  - 빠른 피드백 지표에서 매우 낮은 점수를 받고
  - 유지 보수성이 결여돼 있는데, 프로세스 외부 의존성을 유지해야 한다.
  - 따라서 가장 중요한 기능에 적용해야 한다.

테스트 피라미드에 예외가 있을 수 있는데, 모든 어플리케이션이 비즈니스 규칙이나 기타 복잡도가 거의 없는 기본적인 CRUD 작업이라면, 테스트 피라미드는 단위 테스트와 통합 테스트의 수가 같고 E2E가 없는 직사각형처럼 보일 것이다.

### 4.5.2 블랙박스 테스트와 화이트박스 테스트 간의 선택
- 다음 두 가지 방식을 각각 언제 사용하는지 살펴본다.

1. 블랙박스 테스트는 시스템 내부 구조를 몰라도 시스템의 기능을 검사할 수 있는 소프트웨어 테스트 방법이다.
   - 일반적으로 명세와 요구사항, 어플리케이션이 어떻게 해야 하는지가 아니라 무엇을 해야 하는지를 중심으로 구축한다.
2. 화이트박스 테스트는 정반대다. 어플리케이션 내부 작업을 검증하는 테스트 방식이며, 테스트는 요구 사항이나 명세가 아닌 소스 코드에서 파생된다.

각자 장단점이 있는데, 화이트박스 테스트가 더 철저한 편이다.
- 소스 코드를 분석 시 외부 명세에만 의존할 때 놓칠 수 있는 많은 오류를 발견할 수 있다.
- 반면에 특정 구현과 결합돼 있기 때문에 깨지기 쉽다.
- 이러한 테스트는 거짓 양성을 많이 내고 리팩터링 내성 지표가 부족하다.

| 구분 | 회귀 방지 | 리팩터링 내성|
|--|--|--|
|화이트박스 테스트| 좋음 | 나쁨 |
|블랙박스 테스트 | 나쁨 | 좋음 |

리팩터링 내성은 타협할 수 없다.
=> 따라서 블랙박스 테스트를 기본으로 선택하라.
- 모든 테스트가 시스템을 블랙박스로 보게 만들고 문제 영역에 의미 있는 동작을 확인하라.
- 테스트를 통해 비즈니스 요구 사항으로 거슬러 올라갈 수 없다면, 이는 테스트가 깨지기 쉬움을 나타낸다.
- 이 테스트를 재구성하거나 삭제하라.
- 기존 테스트 스위트로 두지 말라.

테스트 작성 시 블랙박스 테스트가 바람직하지만, 테스트 분석 시 화이트박스 방법을 사용할 수 있다.
- 코드 커버리지 도구를 사용해서 어떤 코드 분기를 실행하지 않았는지 확인한 다음 코드 내부 구조에 대해 전혀 모르는 것처럼 테스트하라.
- 이러한 조합이 가장 효과적이다.

## 요약
- 좋은 단위 테스트에는 단위 테스트, 통합 테스트, E2E 테스트 등 자동화된 테스트를 분석하는 데 사용할 수 있는 네 가지 기본 특성이 있다.
  - 회귀 방지
  - 리팩터링 내성
  - 빠른 피드백
  - 유지 보수성
- 회귀 방지는 테스트가 얼마나 버그의 존재를 잘 나타내는지에 대한 척도다.
- 리팩터링 내성은 테스트가 거짓 양성을 내지 않고 코드 리팩터링을 유지할 수 있는 정도를 의미한다.
  - 거짓 양성은 허위 경보다. 익숙해지면 주의를 기울이지 않기 때문에 테스트의 의미가 희석된다.
  - 거짓 양성은 내부 구현 세부 사항과 테스트 간의 강결합의 결과다.
  - 결합도를 낮추려면 SUT가 만든 최종 결과를 검증해야 한다.
- 회귀 방지와 리팩터링 내성은 테스트 정확도에 기여한다.
- 거짓 양성은 프로젝트가 성장함에 따라 점점 더 중요해진다. 즉, 거짓 음성 (알려지지 않은 버그)만큼 중요하다.
- 빠른 피드백은 테스트가 얼마나 빨리 실행되는지에 대한 척도다.
- 유지 보수성은 두 가지 요소로 구성된다.
  - 테스트 이해 난이도. 작을수록 읽기 쉽다.
  - 테스트 실행 난이도. 테스트에 관련된 프로세스 외부 의존성은 적을수록 쉽게 운영할 수 있다.
- 테스트의 가치 추정은 네 가지 특성 각각에서 얻은 곱이다.
  - 하나가 0이 되면 테스트 가치도 0이다.
- 회귀 방지, 리팩터링 내성, 빠른 피드백은 상호 배타적이기 때문에 모두 최대 점수를 받는 것은 불가능하다.
  - 리팩터링 내성은 타협할 수 없다. 테스트에 이 속성의 여부는 있거나 없거다이다.
  - 절충은 회귀 방지와 빠른 피드백 사이의 선택으로 귀결된다.
- 테스트 피라미드는 단위 테스트, 통합 테스트, E2E 테스트의 일정한 비율을 일컫는다.
  - 보통 E2E가 가장 적고, 단위 테스트가 가장 많고, 통합 테스트는 중간 정도다.
  - E2E는 회귀 방지를 선호하는 데 반해, 단위 테스트는 빠른 피드백을 선호한다.
- 테스트 작성 시 블랙박스 테스트 방법을 사용하라.
- 테스트 분석할 때는 화이트박스 방법을 사용하라.

> 테스트 특성 4가지 중 빠른 피드백과 회귀 방지에 많이 신경을 쓰고 있었다. 즉, 단위 테스트 작성에만 생각을 하고 있었는데, 세부 구현과 결합된 테스트에 대해선 신경을 쓰지 못하고 있었다. 아마 세부 구현을 리팩터링할 경우 거짓 양성이 발생하여 리팩터링 내성이 많이 낮을 수도 있겠다는 생각을 했다.