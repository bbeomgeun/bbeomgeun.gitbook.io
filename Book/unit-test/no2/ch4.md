# 4장 좋은 단위 테스트의 4대 요소
> 좋은 단위 테스트를 구성하고 이 책 전체에서 사용되는 공통적인 기준틀이 되는 4대 요소를 정의한다.

- 가치 있는 테스트를 식별하는 것과 가치 있는 테스트를 작성하는 것은 별개의 기술이다.
- 가치 있는 테스트를 작성하려면 가치 있는 테스트를 식별할 수 있어야 한다.
- 이번 장에서는 가치 있는 테스트를 식별하는 방법을 알아본다.

## 4.1 좋은 단위 테스트의 4대 요소 자세히 살펴보기
1. 회귀 방지
2. 리팩터링 내성
3. 빠른 피드백
4. 유지 보수성

### 4.1.1 첫 번째 요소: 회귀 방지
- 회귀는 소프트웨어 버그다.
  - 코드를 수정한 후 기능이 의도한 대로 작동하지 않는 경우다.
  - 코드베이스가 커질수록 잠재적인 버그에 더 많이 노출된다.
  - 따라서 회귀에 대해 효과적인 보호를 개발하는 것이 중요하다.
    - 이러한 보호가 없다면 프로젝트가 오랫동안 성장할 수 없으며 점점 더 많은 버그가 쌓일 것이다.

- 회귀 방지 지표에 대한 평가는 다음 사항을 고려해야 한다.
1. 테스트 중에 실행되는 코드의 양
2. 코드 복잡도
3. 코드의 도메인 유의성

일반적으로 실행되는 코드가 많을수록 테스트에서 회귀가 나타날 가능성이 높다.
또한, 코드의 양뿐만 아니라 복잡도와 도메인 유의성도 중요하다.
- 복잡한 비즈니스 로직의 코드가 보일러플레이트 코드보다 훨씬 더 중요하다.
- 비즈니스 버그가 가장 큰 피해를 입히기 때문이다.
- 반면 단순한 코드를 테스트하는 것은 가치가 거의 없다.

> 팁
> - 회귀 방지 지표를 극대화하려면 테스트가 가능한 한 많은 코드를 실행하는 것을 목표로 해야 한다.
> - 버그를 막아주는 테스트 코드, 특히 핵심 비즈니스 로직을 테스트하는 단위 테스트가 좋은 단위 테스트이다.

### 4.1.2 두 번째 요소: 리팩터링 내성
- 좋은 단위 테스트의 두 번째 특징은 리팩터링 내성이다. 이는 테스트를 '빨간색'으로 바꾸지 않고 기본 어플리케이션 코드를 리팩터링할 수 있는지에 대한 척도다.

> 리팩터링은 식별할 수 있는 동작을 수정하지 않고 기존 코드를 변경하는 것을 의미한다.
> - 그 의도는 코드의 비기능적 특징을 개선하는 것으로 가독성을 높이고 복잡도를 낮추는 것이다.

- 상황 가정
  - 새로운 기능을 개발했으며 모든 것이 잘 작동한다.
  - 기능이 제 역할을 하고 있으며, 모든 테스트가 통과하고 있다.
  - 이제 코드를 정리하기로 결정했다.
    - 리팩터링으로 정확히 무엇이 고장 났는지 자세히 살펴봤지만, 아무것도 고장 나지 않았다.
    - 문제는 기반 코드를 수정 시 테스트가 빨간색으로 바뀌게끔 작성됐다는 것이다.
    - 그리고 실제로 기능이 작동하지 않는지는 상관없다.
      - 이러한 상황을 **거짓 양성**이라고 한다. 허위 경보인 셈이다.
      - 코드는 잘 동작하지만 테스트는 실패를 나타내는 결과다.

거짓 양성이 적을수록 리팩터링 내성 지표에서 테스트 점수가 잘 나올 것이다.

- 왜 거짓 양성을 신경써야 할까?
  - 단위 테스트의 목표는 프로젝트 성장을 지속 가능하게 하는 것이다.
  - 테스트가 지속 가능한 성장을 하게 하는 메커니즘은 **회귀 없이 주기적으로 리팩터링하고 새로운 기능을 추가**할 수 있는 것이다.
  - 장점
    1. 기존 기능이 고장 났을 때 테스트가 조기 경고를 제공한다. 운영 환경에 배포되기 전에 결함이 있는 코드를 고칠 수 있다.
    2. 코드 변경이 회귀로 이어지지 않을 것이라고 확신하게 된다. 확신이 없으면 리팩터링을 하는 데 주저하게 되고 코드베이스가 나빠질 가능성이 있다.
  - 거짓 양성은 이 두 가지 이점을 모두 방해한다.
    1. 테스트가 타당한 이유 없이 실패하면, 코드 문제에 대응하는 능력과 의지가 희석된다. 시간이 지나며 실패에 익숙해지고 신경 쓰지 않으며 무시하기 시작한다.
    2. 거짓 양성이 빈번해지면, 테스트 스위트에 대한 신뢰가 떨어지며 믿을 만한 안정망으로 인식하지 않는다. 즉, 허위 경보로 인식이 나빠진다.
- 즉, 계속 "늑대"라고 외치는 양치기 소년 같은 테스트에 질려서 점점 무시하기 시작한다.
- 무시하기 시작하며 버그가 운영 환경에 릴리즈 되는 순간이 오게 된다.

### 4.1.3 무엇이 거짓 양성의 원인인가?
- 테스트에서 발생하는 거짓 양성의 수는 테스트 구성 방식과 직접적인 관련이 있다.
- 테스트와 테스트 대상 시스템(SUT)의 구현 세부 사항이 많이 결합될수록 허위 경보가 더 많이 생긴다.
  - 따라서 거짓 양성을 줄이는 방법은 해당 구현 세부 사항에서 테스트를 분리하는 것 뿐이다.
  - 테스트를 통해 SUT가 제공하는 최종 결과를 검증하는지 확인해야 한다.
  - 즉, 최종 사용자에게 의미 있는 결과만 확인해야 한다. 다른 것은 무시해야 한다.
- 테스트를 구성하기에 가장 좋은 방법은 문제 영역에 대해 이야기하는 것이다.
  - 이 테스트가 실패하면 실제로 어플리케이션 동작과 이야기가 서로 분리되는 것을 의미한다.
  - 그 외 실패는 소음일뿐이다.

테스트를 구현에 신경 쓴다고 하면
- 최종 결과가 바뀌지 않더라도, 테스트를 수행 시 빨간색으로 변할 것이다.
- 이는 테스트가 SUT가 생성한 결과가 아니라 SUT의 구현 세부사항과 결합했기 때문이다.
  - 이런 테스트는 리팩터링 내성이 없다.
  - 식별할 수 있는 동작을 고려하지 않고 특정한 구현에만 고집한다.
  - 따라서 내부 구현이 변경될 때마다 테스트가 실패할 것이다.

### 4.1.4 구현 세부 사항 대신 최종 결과를 목표로 하기
- 테스트를 깨지지 않게 하고 리팩터링 내성을 높이는 방법은 SUT의 구현 세부 사항과 테스트 간의 결합도를 낮추는 것뿐이다.
- 코드의 내부 작업과 테스트 사이를 가능한 한 멀리 떨어뜨리고 최종 결과를 목표로 하는 것이다.
- 최종 사용자에게 의미 있는 유일한 결과, 방식을 검증해 비즈니스 요구 사항에 들어맞게끔 작성하자.
- 메서드에 새 매개변수를 도입하면 컴파일 오류가 발생할 수 있다.
  - 기술적으로 이러한 오류도 거짓 양성으로 간주하지만, 컴파일러를 따라 새 매개변수를 추가하면 된다.
  - 좋지 않은 거짓 양성은 컴파일 오류를 내지 않는 것이다.
  - 처리하기 까다롭다.
  - 조사하는데 많은 시간을 들여야 하기 때문이다.

> 테스트의 세부 구현까지 모두 테스트하려는 시도가 오히려 리팩토링 내성이 없는 테스트 코드를 작성하는 행위였다.