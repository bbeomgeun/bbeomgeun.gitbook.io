# 27장 '크고 작은 모든' 서비스들

> SOA와 MSA는 최근에 큰 인기를 끌고 있는데 왜 그럴까?
> 1. 서비스를 사용하면 상호 결합이 철저하게 분리되는 것처럼 보인다. 또한, 개발과 배포 독립성을 지원하는 것처럼 보인다. 모두 일부만 맞는 말이다.

## 서비스 아키텍처?
- **서비스를 이용한다는 것이 본직적으로 아키텍처에 해당할까? 아니다.**
- 시스템의 아키텍처는 의존성 규칙을 준수하며 고수준의 정책을 저수준의 세부사항으로부터 분리하는 경계에 의해 정의된다.
  - **단순히 행위를 분리한 서비스는 값비싼 함수 호출에 불과하다.**
- 기능을 프로세스나 플랫폼에 독립적이 되게끔 서비스들을 생성하면 의존성 규칙 준수 여부와 상관 없이 큰 도움이 될 때가 있다. 그러나 그 자체로는 아키텍처를 정의하지 않는다.
- 함수들의 구성 형태도 이와 비슷하다.
  - 시스템에서 아키텍처를 정의하는 요소는 바로 의존성 규칙을 따르며 아키텍처 경계를 넘나드는 함수 호출들이다.

## 서비스의 이점?
- 현재 인기를 끄는 서비스 아키텍처에 대해 이의를 제기할 것이다.

### 결합 분리의 오류
- 시스템을 서비스들로 분리함으로써 얻게 되는 이점은 서비스 사이 결합이 확실히 분리된다는 점이다. 각각 서로 다른 프로세스, 프로세서에서 실행된다.
- 결합이 확실히 분리되었을까?
  - 프로세서 내의 또는 네트워크 상의 공유 자원 때문에 결합될 가능성이 여전히 존재한다.
  - 서로 공유하는 데이터에 의해 이들 서비스는 강력하게 결합되어 버린다.
    - 서비스 사이를 오가는 데이터 레코드에 새로운 필드를 추가한다면, 관련된 모든 서비스는 반드시 변경되어야 한다.
    - 또한, 이 필드에 담긴 데이터를 해석하는 방식을 사전에 완벽하게 조율해야 한다.
  - 인터페이스가 잘 정의되어 있어야 한다는 이점은 명백히 사실이다. 하지만 함수의 경우에도 전혀 다르지 않다.
    - 서비스 인터페이스나 함수 인터페이스의 차이가 더 엄밀하고 엄격하거나 그러지는 않는다.

### 개발 및 배포 독립성의 오류
- 또 다른 이점은 전담팀이 서비스를 소유하고 운영한다는 점이다.
- 이러한 개발 및 배포 독립성은 확장 가능한 것으로 간주된다.
- 대규모 엔터프라이즈 시스템을 독립적으로 개발하고, 배포 가능한 수십, 수백, 수천 개의 서비스들을 이용하여 만들 수 있다고 믿는다.
  - 대규모 엔터프라이즈 시스템은 서비스 기반 시스템 이외에도, 모놀리틱 시스템으로도 구축 가능하다.
  - 또한, 결합 분리의 오류에 따르면 서비스라고 해서 항상 독립적으로 개발 배포 운영이 가능하진 않는다.
    - 결합된 서비스에 의해 개발 배포 순서, 운영 등이 의존되어 있다.
> 해당 서비스를 사용하는 다른 서비스들이 변경에 대해 의존적이고, 배포 순서도 의존적일 수 있다.

## 야옹이 문제
- 택시 통합 시스템 이야기
- 여러 개의 MSA로 나눠서, 운영 및 유지보수를 하고 있었는데 마케팅 부서에서 야옹이를 배달하는 서비스를 제공하겠다는 게획을 발표한다.
- 현재 서비스 구조에서는 모든 서비스를 변경해야 한다.
  - 서비스들은 모두 결합되어 있어서 독립적으로 개발하고 배포하거나 유지될 수 없다.
- 횡단 관심사가 지닌 문제로, 모든 sw 시스템은 서비스 지향이든 아니든 이 문제에 직면하게 마련이다.
- **기능적 분해는 새로운 기능이 기능적 행위를 횡단하는 상황에 매우 취약하다.**

## 객체가 구출하다
- 컴포넌트 기반 아키텍처에서는 다형적으로 확장할 수 있는 클래스 집합을 생성해 새로운 기능을 처리하도록 했다.
- 원래 서비스의 로직 중 대다수가 이 객체 모델의 기반 클래스들 내부로 녹아들었다.
  - 배차에 특화된 로직은 Rides 컴포넌트로, 야옹이에 대한 신규 기능은 Kittens 컴포넌트에 들어갔다.
  - 이 두 컴포넌트는 기존 컴포넌트들에 있는 추상 기반 클래스를 템플릿 메서드나 전략 패턴 등을 이용해서 오버라이드한다.
- 야옹이 기능은 결합이 분리되며, 독립적으로 개발하여 배포할 수 있게 되었다.
  - 새로운 기능을 구현한 jar 파일 등을 시스템에 추가하고, 런타임에 동적으로 로드하면 된다.

## 컴포넌트 기반 서비스
- "서비스에서도 이렇게 할 수 있을까?"에 대한 대답은 "예"다.
- 서비스를 SOLID 원칙대로 설계하고, 컴포넌트 구조를 갖춘다면 기존 컴포넌트를 변경하지 않더라도 새로운 컴포넌트를 추가함으로써 대응할 수 있다.
- 서비스 내에 추상 클래스를 확장해서 만들면서 기능이 추가된다고 한다면, 단순히 새롭게 구현한 jar파일을 추가하는 문제로 변경된다.
  - 새로운 기능을 추가하는 행위만 하면 되므로 개방 폐쇄 원칙을 준수하게 된다.
- 각 서비스 내부는 자신만의 컴포넌트 설계로 되어 있음으로써 파생 클래스를 만드는 방식으로 신규 기능을 추가할 수 있다.

## 횡단 관심사
- 아키텍처 경계는 서비스 사이에 있지 않다.
- MSA 경계가 아키텍처의 경계가 아니고, 모든 서비스를 횡단으로 관통하는 관심사가 있을 수 있다.
- 모든 주요 시스템이 직면하는 횡단 관심사를 처리하려면, 서비스 내부는 의존성 규칙도 준수하는 컴포넌트 아키텍처로 설계해야 한다.
- **즉, 서비스를 분리하더라도 내부 컴포넌트가 의존성 규칙을 준수해야 하고 해당 컴포넌트들의 경계가 아키텍처의 경계를 정의한다.**
> 마이크로 서비스 내부의 레이어 간 의존성이 곧 아키텍처의 경계이다.

## 결론
- MSA는 시스템의 확장성과 개발 가능성 측면에서는 유용하지만, 아키텍처적으로 그리 중요한 요소는 아니다.
- 시스템 아키텍처는 시스템 내부에 그어진 경계와 경계를 넘나드는 의존성에 의해 정의된다.
  - 서비스 간 통신하고 실행되는 물리적인 메커니즘에 의해 시스템 아키텍처가 정의되지 않는다.
- 서비스는 단일 컴포넌트로도, 다수의 컴포넌트로도 구성할 수 있다.

> 단순히 서비스를 분리했다고 해서, 아키텍처의 경계가 나뉜 것은 아니다. 각 서비스들의 컴포넌트들이 의존성 규칙을 준수하고 있도록 설계해야 횡단 관심사 (모든 서비스에 변경을 일으키는) 를 처리할 수 있다.