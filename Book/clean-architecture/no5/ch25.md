# 25장 계층과 경계
- 시스템이 세 가지 컴포넌트 (UI, 업무 규칙, 데이터베이스)로만 구성된다고 생각하기 쉽다. 하지만 대다수의 시스템에서 컴포넌트 개수는 이보다 훨씬 많다.

## 움퍼스 사냥 게임
- 소스 코드 의존성을 잘 관리하면, UI 컴포넌트가 언어의 종류를 변경하더라도 상위 규칙은 신경쓰지 않아도 된다. 또한 게임의 상태를 어떤 저장소에서 관리하는지 세부사항 역시 알 필요가 없어진다.

## 클린 아키텍처?
- 중요한 아키텍처 경게를 더 발견할 수 있다.
- 이 변경의 축에 의해 정의되는 아키텍처 경계를 격리해보자.
- 변형들은 추상 API 컴포넌트가 정의하는 다형적 인터페이스를 통해 제공되고, 실제로 서비스하는 구체 컴포넌트가 해당 인터페이스를 구현한다.
- 이 구성은 데이터의 흐름을 두 개의 흐름으로 효과적으로 분리했다.

## 흐름 횡단하기
- 데이터의 흐름이 항상 두 가지일까? 아니다.
- 사냥 게임을 네트워크상에서 여러 사람이 함께 플레이해야 한다면?
- 네트워크 컴포넌트가 추가되어야 하고, 흐름은 여러 개가 되었다.
- 따라서 시스템이 복잡해질수록 컴포넌트 구조는 더 많은 흐름으로 분리될 것이다.

## 흐름 분리하기
- 모든 흐름이 결국에는 상단의 단일 컴포넌트에서 서로 만날까? 훨씬 복잡할 것이다.
- 단순히 GameRules 컴포넌트가 하나의 규칙을 처리하는 것이 아닌, 여러 개의 정책 집합을 관리할 수 있다.
- 게임의 저수준 정책이 고수준 정책에게 메세지를 전달하며 플레이어의 상태를 관리한다.
- 대규모의 플레이어가 플레이 한다고 가정하면, MoveMangement는 플레이어의 컴퓨터에서 직접 처리되지만, PlayerManagement는 서버에서 처리된다.
- PlayerManagement는 접속된 모든 MoveManagement 컴포넌트에 API를 제공한다.
- 두 개의 사이에 아키텍처 경계가 존재한다.

## 결론
- 아키텍처 경계를 모두 추론해 내는 이유는 무엇일까?
- 아키텍처 경계는 어디에나 존재한다는 사실을 보여주기 위함이다. 아키텍트로서 우리는 아키텍처 경계가 언제 필요한지를 신중하게 파악해내야 한다. 그리고 이러한 경계를 제대로 구현하려면 비용이 많이 든다는 사실도 인지해야 한다. + 경계가 무시되었다면 나중에 다시 추가하는 비용도 크다는 것이다.
- 그러면 어떻게 해야할까?
  - 추상화가 필요하리라고 미리 예측해서는 안된다. YAGNI(you aren't going to need it)의 철학이다. 오버 엔지니어링이 언더 엔지니어링보다 나쁠 때가 훨씬 많기 때문이다.
- 따라서 우리는 미래를 현명하게 추측해야만 한다.
- 시스템이 발전함에 따라 주의를 기울여야 한다.