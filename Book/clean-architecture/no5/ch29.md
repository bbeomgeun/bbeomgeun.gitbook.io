# 29장 클린 임베디드 아키텍처
> 소프트웨어는 닳지 않지만, 펌웨어와 하드웨어는 낡아 가므로 결국 소프트웨어도 수정해야 한다.

## 앱-티튜드 테스트
- 왜 잠재적인 임베디드 소프트웨어는 펌웨어로 많이 변하는가?
  - 임베디드 코드가 동작하게 만드는 데 대부분의 노력을 집중하고, 오랫동안 유용하게 남도록 구조화하는 데는 그리 신경쓰지 않기 때문으로 보인다.
  - 켄트백은 소프트웨어를 구축하는 세 가지 활동을 다음과 같이 기술했다.
    - 먼저 동작하게 만들어라.
    - 그리고 올바르게 만들어라.
    - 그리고 빠르게 만들어라.
- 현장의 수많은 임베디드 시스템 소프트웨어는 동작하게 하라만을 염두하고 작성된 것처럼 보인다.
- 또는 빠르게 만들어라라는 목표에도 집작하는데, 아주 세세한 최적화를 틈만 나면 수행해야 달성되는 목표이다.
- 이러한 문제들은 임베디드 소프트웨어뿐만 아니라, 대다수의 앱들도 코드를 올바르게 작성해서 유효 수명을 길게 늘리는 데는 거의 관심 없이, 그저 동작하도록 만들어진다.

- 단순히 앱이 동작하도록 만드는 것에만 신경쓰는 건 옳지 않다.
- 동작은 하지만, 유효 수명을 신경쓰지 않는다면 클린 임베디드 아키텍처를 가진다고 말하기는 어렵다.

## 타깃-하드웨어 병목현상
- 임베디드 개발자는 임베디드가 아니었다면 다루지 않아도 될 특수한 관심사를 많이 갖고 있다.
  - 제한된 메모리 공간, 실시간성 제약과 처리완료 시간, 제한된 입출력, 특이한 사용자 인터페이스, 여러 센서와 실제 세상과의 상호작용 등...
- 임베디드 코드를 클린 아키텍처 원칙을 지키지 않는다면, 타깃-하드웨어 병목현상 문제가 발생할 것이고, 대개의 경우 코드를 테스트할 수 있는 환경이 해당 특정 타깃으로 국한될 것이다.
  - 그리고 그 타깃이 테스트가 가능한 유일한 장소라면 타깃-하드웨어 병목현상이 발생하여 진척이 느려질 것이다.

### 클린 임베디드 아키텍처는 테스트하기 쉬운 임베디드 아키텍처다
- 몇 가지 아키텍처 원칙을 적용하여 타깃-하드웨어 병목현상을 줄이는 방법을 살펴보자.

#### 계층
- 소프트웨어 <-> 펌웨어 <-> 하드웨어로 계층을 나눠보자.
- 하드웨어는 기술의 발전괌 무어의 법칙에 따라 변할 것이다.
- 어떤 이유에서든, 이처럼 불가피하게 하드웨어를 변경해야 하는 시점이 닥쳤을 때, 임베디드 엔지니어로서 필요 이상의 작업을 하기를 원치 않는다.
- 하드웨어는 시스템의 나머지 부분으로부터 반드시 분리되어야 한다.
- 소프트웨어와 펌웨어가 서로 섞이는 일은 안티 패턴이다.
  - 안티 패턴을 보이는 코드는 변화에 저항하게 되고, 때로는 의도치 않은 결과를 불러온다.

#### 하드웨어는 세부사항이다
- 소프트웨어와 펌웨어 사이의 경계는 코드와 하드웨어 사이의 경계와는 달리 잘 정의하기가 대체로 힘들다.
- 이 경계를 분명하게 만드는 것이 중요한데, 소프트웨어와 펌웨어 사이의 경계는 하드웨어 추상화 계층 (HAL)이라 부른다.
  - HAL은 자신보다 위에 있는 소프트웨어를 위해 존재하므로, HAL의 API는 소프트웨어의 필요에 맞게 만들어져야 한다.
    - 소프트웨어는 데이터가 어떤 영속성 장치에 저장되는지 알 필요가 없다.
    - 이러한 서비스는 HAL이 제공하며, 어떻게 저장하는지에 대해서는 소프트웨어에게 드러내지 않는다.

### HAL 사용자에게 하드웨어 세부사항을 드러내지 말라
- 클린 임베디드 아키텍처로 설계된 소프트웨어는 타깃 하드웨어에 관계 없이 테스트가 가능하다. HAL이 제대로 동작한다면, 타깃에 상관없이 테스트할 수 있는 경계층 또는 일련의 대체 지점을 제공한다.

#### 프로세서는 세부사항이다
- 특수한 툴 체인을 사용시, 툴 체인은 도움이 되는 헤더파일을 제공할 때가 많다. 해당 툴 체인의 컴파일러는 C언어를 제멋대로 변경하여 해당 업체의 프로세서 기능에 접근할 수 있는 새로운 키워드를 제공하곤 한다. C언어처럼 보이지만, 더 이상 C언어가 아닌 특정 컴파일러에 종속된 언어가 된다.
  - 다른 프로세서에서는 컴파일되지 않을 것이고, 심지어 동일한 프로세서라도 다른 컴파일러로는 컴파일되지 않을 수 있다.
- 코드가 특정 상황에 종속되어 버리면, 타깃이 아닌 하드웨어에서 코드를 테스트할 수 없고, 다른 프로세서로 어플리케이션을 이식하기를 원할 때 더 큰 문제가 터진다.
  - 특정 상황의 헤더 파일을 사용하지 말고, 최대한 표준화된 헤더를 사용하려 노력해야 한다. 
- 모든 소프트웨어는 반드시 프로세서에 독립적이야 함이 분명하지만, 모든 펌웨어는 그럴 수 없다.
  - 클린 임베디드 아키텍처라면 장치 접근 레지스터를 직접 사용하는 코드는 소수의, 순전히 펌웨어로만 한정시켜야 한다.
  - 이들 레지스터를 알고 있는 것은 모두 펌웨어가 되어야 하며, 따라서 실리콘 칩에 종속된다.
  - 코드를 프로세서와 직접적으로 묶어버리면 안정적인 하드웨어가 출시되기 이전에 코드 실행 시 어려움을 겪을 수 있고, 새로운 프로세서로 이식 시 곤란해질 것이다.
- 펌웨어가 저수준 함수들을 PAL(Processor Abstraction Layer) 프로세서 추상화 계층의 형태로 격리시켜줄 수 있다.

#### 운영체제는 세부사항이다
- HAL은 필수적이다. 베어메탈(어떤 소프트웨어도 담겨 있지 않은 하드웨어) 임베디드 시스템이라면, 코드가 운영 환경에 깊숙이 종속되지 않도록 만드는 데 HAL만으로도 충분할 것이다.
  - 하지만 임베디드 시스템에서 실시간 운영체제를 사용하거나, 임베디드 버전의 리눅스/윈도우를 사용한다면?
- 작성한 코드의 수명을 늘리려면, 무조건 운영체제를 세부사항으로 취급하고 운영체제에 의존하는 일을 막아야 한다.
- OS는 소프트웨어를 펌웨어로부터 분리하는 계층이다.
  - OS를 직접 사용하면 문제가 된다.
  - 변경 시 새로운 OS가 제공하는 기능에 맞춰 변경이 필요해진다.
- 클린 임베디드 아키텍처는 OSAL(Operation System Abstraction Layer) 운영체제 추상화 계층을 통해 소프트웨어를 운영체제로부터 격리시킨다.
  - OS에 직접 의존하지 않고 OSAL에 의존 시, 이식 작업의 대부분은 기존 OSAL과 호환되도록 새로운 OSAL을 작성하는 데 소요될 것이다.
    - 정의된 인터페이스와 행위에 맞게 새로운 코드를 작성하는 일은 기존의 복잡한 코드 덩어리를 수정하는 것보다 훨씬 편할 것이다.
- 코드 비대화 문제가 염려될 수 있지만, 중복이 큰 비용을 초래하지 않는다.
  - OSAL은 테스트 지점을 만드는 데 도움이 되며, 그 덕분에 소프트웨어 계층의 어플리케이션 코드를 타깃이나 OS와 관계없이 테스트할 수 있게 된다.

### 인터페이스를 통하고 대체 가능성을 높이는 방향으로 프로그래밍하라
- HAL과 OSAL 등 모든 주요 계층 내부에 원칙을 적용할 수 있다.
  - 관심사를 분리시키고, 인터페이스를 활용하며, 대체 가능성을 높이는 방향으로 프로그래밍하도록 유도한다.
- 계층형 아키텍처는 인터페이스를 통해 프로그래밍하자는 발상을 기반으로 한다.
  - 모듈들이 서로 인터페이스를 통해 상호작용한다면 쉽게 대체가 가능해진다.
- 인터페이스 정의 시, 구현 세부사항의 가시성을 제한 후 세부사항은 항상 변경될 거라고 가정하자. 세부사항을 알고 있는 부분이 적을수록 추적하고 변경해야 할 코드도 적어진다.

### DRY 원칙 : 조건부 컴파일 지시자를 반복하지 말라
- 조건부 컴파일 사례
  - 특정 코드 블록을 활성화 또는 비활성화에 사용되는 구문이 수천 번이나 사용되었다.
  - Don't Repeat Yourself 원칙을 위배하게 된다.
- HAL이 있었다면, 하드웨어 유형은 HAL 뒤의 세부사항이 될 것이고 조건부 컴파일 대신 사용할 수 있는 일련의 인터페이스를 제공한다면 링커 또는 어떤 형태의 실시간 바인딩을 사용해서 소프트웨어와 하드웨어를 연결할 수 있다.

## 결론
- 모든 코드가 펌웨어가 되도록 내버려두면 제품이 오래 살아남을 수 없게 된다.
- 오직 타깃 하드웨어에서만 테스트할 수 있는 제품도 마찬가지다.
- 클린 임베디드 아키텍처는 제품이 장기간 생명력을 유지하는 데 도움을 준다.